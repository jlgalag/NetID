sub printUsage {
	print "Usage: ./csv2ldif input_csv_file output_ldif_file\n";
}

sub lowCaser {
	$_[0] =~ s/Ñ/ñ/g;
	$_[0] = lc($_[0]);
	$_[0] =~ s/([(\w|ñ)']+)/\u\L$1/g;
	return($_[0]);
}

sub fixTokensCase {
	#Indices	Value
	# 1		Last Name
	# 2		First Name
	# 3		Middle Name
	# 4		Nick Name
	# 5		Name Suffix
	$tokens[1] = &lowCaser($tokens[1]);
	$tokens[2] = &lowCaser($tokens[2]);
	$tokens[3] = &lowCaser($tokens[3]);
	$tokens[4] = &lowCaser($tokens[4]);
	$tokens[5] = &lowCaser($tokens[5]);
}

sub fixTokensCaseStud {
	# 7		Classification
	# 8		Office/College
	$tokens[7] = &lowCaser($tokens[7]);
	$tokens[8] = &lowCaser($tokens[8]);
}

sub cnProducer {
	my $temp = substr($tokens[3], 0, 1);
	return "$tokens[1], "."$tokens[2] ".${temp};
}

sub checkIfUIDUnique {
	# If UID is unique, return true; else return TRUE
	my $uniqueFlag = 1;
	#check if uid already exists on the LDAP server
	$mesg = $ldap->search(
                        base   => "dc=uplb,dc=edu,dc=ph",
                        filter => "(uid=$_[0])",
                      );
	$temp_counter = $mesg->count;
	# DEBUG print "Matches: $mesg->count\n";
	# $mesg->count = 0 if uid not found on server	
	if ($mesg->count==0){
		#Check previous usernames in the list. Returns true if uid already exists.	
		if (  exists($uids_hash{$_[0]}) ){
			# DEBUG print "UID exists in hash\n";
			$uniqueFlag = 0;
		}
	} else {
		$uniqueFlag = 0;
	}
	#DEBUGif (!$uniqueFlag){
	#DEBUG	print "DUPLICATE found for: $uid\n";
	#DEBUG}
	return($uniqueFlag);
}

sub uidProducer {
	# Sample case: Tirazona, Ludwig Johann Berino
	# Version 1: ljbtirazona
	# Version 2: ludwigjbtirazona
	# Version 3: ludwigjbtirazona1
	# Version 4: ludwigjbtirazona2
	# Version 5 should die.

	# uidAccepted becomes 1 when uid is already found to be unique.
	my $uidAccepted = 0;
	#Version 1
	#Most Filipino first names are actually two names.
	$uid = "";
	@temp = split(" ", $tokens[2]);
	foreach $name (@temp) {
		$uid = $uid . substr($name, 0, 1);
	}
	$uid .= substr($tokens[3], 0, 1) . $tokens[1];
	$uid = lc($uid);
	#affix suffix
	$temp = $tokens[5];	
	$temp = lc($temp);
	$temp =~ s/\.|\s//g;
	$uid .= $temp;
	#eliminate dashes
	$uid =~ s/-//g;
	#eliminate Ñ's
	$uid =~ s/ñ/n/g;
	#eliminate all spaces
	$uid =~ s/\s//g;
	#End Version 1
	if (&checkIfUIDUnique($uid)){
		$uidAccepted = 1;
		$uids_hash{$uid} = 1;
		say OUTPUT_LDIF "uid: $uid";
	}	

	if (!$uidAccepted){
	#Version 2
		$uid = "";
		@temp = split(" ", $tokens[2]);
		$uid .= $temp[0];
		$uid .= substr($temp[1], 0, 1);
		$uid .= substr($tokens[3], 0, 1) . $tokens[1];
		$uid = lc($uid);
		#affix suffix
		$temp = $tokens[5];	
		$temp = lc($temp);
		$temp =~ s/\.|\s//g;
		$uid .= $temp;
		#eliminate dashes
		$uid =~ s/-//g;
		#eliminate Ñ's
		$uid =~ s/ñ/n/g;
		if (&checkIfUIDUnique($uid)){
			$uidAccepted = 1;
			$uids_hash{$uid} = 1;
			say OUTPUT_LDIF "uid: $uid";
		}	
	}
	if (!$uidAccepted){
	#Version 3
		$uid .= "1";

		if (&checkIfUIDUnique($uid)){
			$uidAccepted = 1;
			$uids_hash{$uid} = 1;
			say OUTPUT_LDIF "uid: $uid";
		}	

	}
	if (!$uidAccepted){
	#Version 4
		$uid =~ s/1$/2/g;
		if (&checkIfUIDUnique($uid)){
			$uidAccepted = 1;
			$uids_hash{$uid} = 1;
			say OUTPUT_LDIF "uid: $uid";
		}	

	}
	if (!$uidAccepted){
	#Version 5
		print "Fatal Error: No acceptable UID found for\n";
		foreach my $totokens (@tokens){
			print "$totokens ";
		}
		print "\n";
		exit(1);
	}
}

sub passwdProducer {
	# userPassword: <generated by pwgen>
	# securityQuestion: <generated by pwgen>
	# securityAnswer: <generated by pwgen>
	$ctx = Digest::SHA->new;
	$ctx->add($passwords_generated[$entryCounter*4]);
	$ctx->add($passwords_generated[($entryCounter*4)+1]);
	$hashedPasswd = '{SSHA}' . encode_base64($ctx->digest . $passwords_generated[($entryCounter*4)+1] ,'');
	$ctx = Digest::SHA->new;
	$ctx->add($passwords_generated[($entryCounter*4)+3]);
	$ctx->add($passwords_generated[($entryCounter*4)+1]);
	$hashedAnswer = '{SSHA}' . encode_base64($ctx->digest . $passwords_generated[($entryCounter*4)+1] ,'');
 	say OUTPUT_LDIF "userPassword: $hashedPasswd\nsecurityQuestion: $passwords_generated[($entryCounter*4)+2]\nsecurityAnswer: $hashedAnswer";
	#Output initial plaintext passwords to file
	if($thisFile == 1){ 
		say PASS_PLAIN_DUMP "$uid $passwords_generated[$entryCounter*4]";
	}else {
		say PASS_PLAIN_CSV "$uid $passwords_generated[$entryCounter*4]";
	}
}

sub displayNameProducer {
	&fixTokensCase;
	#fix capitalizations for suffixes
	$tokens[5] =~ s/Iii/III/;
	$tokens[5] =~ s/Ii/II/;	
	#Convert last name to Initials
	$tokens[3] = substr($tokens[3], 0, 1) . ".";
	say OUTPUT_LDIF "displayName: $tokens[1], $tokens[2] $tokens[5] $tokens[3]";
}

sub findDuplicate {
$mesg = $ldap->search(
				base   => "ou=people,dc=uplb,dc=edu,dc=ph",
				filter => "(cn=$identifier)"
			      );
		if ($mesg->count == 1)
		{
			#print "ronTest : found\n";
			if($flag eq 1)
			{
				$mesg = $ldap->search(
					base   => "ou=people,dc=uplb,dc=edu,dc=ph",
					filter => "(&(cn=$identifier)(objectClass=UPLBEmployee))"
				);
				if ($mesg->count == 1){ print "Employee record already present. Proceed to next entry.\n"; return 1;}
				elsif ($mesg->count == 0){ print "$identifier Modify record. Add employee attibutes.\n"; return 2;}
			}
			elsif($flag eq 2)
			{
				$mesg = $ldap->search(
					base   => "ou=people,dc=uplb,dc=edu,dc=ph",
					filter => "(&(cn=$identifier)(objectClass=UPLBStudent))"
				);
				if ($mesg->count == 1){ print "Student record already present. Proceed to next entry.\n"; return 1;}
				elsif ($mesg->count == 0){ print "$identifier Modify record. Add student attibutes.\n"; return 3;}
			}
			else 
			{
				#temporary solution to errors in modifying those that have already been modified
				return 1;
			}
		}elsif ($mesg->count == 0){ print "$identifier ronTest: not found\nAdd entry\n"; return 4;}

}

sub getUIDUPLB {
	 $mesg = $ldap->search(
                base   => "ou=people,dc=uplb,dc=edu,dc=ph",
                filter => "(cn=$identifier)",
                attrs  => "uidNumber"
              );
	foreach $entry ($mesg->entries){
		     return $entry->get_value("uidNumber");
	}
}

sub addEmployeeAttributes {
		say OUTPUT_LDIF "dn: uniqueIdentifierUPLB=$UIDUPLB,ou=people,dc=uplb,dc=edu,dc=ph";
	 	say OUTPUT_LDIF "changetype: modify";
	 	say OUTPUT_LDIF "add: objectClass";
	 	say OUTPUT_LDIF "objectClass: UPLBEmployee";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: title";
	 	say OUTPUT_LDIF "title: employee";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: employeeNumber";
	 	say OUTPUT_LDIF "employeeNumber: $eNumber";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: employeeType";
	 	say OUTPUT_LDIF "employeeType: $tokens[7]";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: ou";
	 	say OUTPUT_LDIF "ou: $tokens[8]";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: o";
	 	say OUTPUT_LDIF "o: $college";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: activeEmployee";
	 	say OUTPUT_LDIF "activeEmployee: TRUE";
	 	say OUTPUT_LDIF;
}

sub addStudentAttributes {
		say OUTPUT_LDIF "dn: uniqueIdentifierUPLB=$UIDUPLB,ou=people,dc=uplb,dc=edu,dc=ph";
	 	say OUTPUT_LDIF "changetype: modify";
	 	say OUTPUT_LDIF "add: objectClass";
	 	say OUTPUT_LDIF "objectClass: UPLBStudent";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: title";
	 	say OUTPUT_LDIF "title: employee";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: studentNumber";
	 	say OUTPUT_LDIF "studentNumber: $eNumber";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: studentType";
	 	say OUTPUT_LDIF "studentType: $tokens[7]";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: course";
	 	say OUTPUT_LDIF "course: $tokens[8]";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: college";
	 	say OUTPUT_LDIF "college: $college";
	 	say OUTPUT_LDIF "-";
	 	say OUTPUT_LDIF "add: activeStudent";
	 	say OUTPUT_LDIF "activeStudent: TRUE";
	 	say OUTPUT_LDIF;
}

sub addNewEntry {
			############
			#UPLBEntity#
			############
		 	say OUTPUT_LDIF "dn: uniqueIdentifierUPLB=$lastUID,ou=people,dc=uplb,dc=edu,dc=ph";
		 	say OUTPUT_LDIF "changetype: add";
		 	say OUTPUT_LDIF "objectClass: UPLBEntity";
		 	#if flag is not equal to -1 the entity is classified as a student, else he is an employee
		 	if($flag == 2)
		 	{
		 		say OUTPUT_LDIF "objectClass: UPLBStudent";
		 		say OUTPUT_LDIF "title: student";
		 		&fixTokensCase;
		 	}
		 	elsif($flag == 1)
		 	{
				say OUTPUT_LDIF "objectClass: UPLBEmployee";
				say OUTPUT_LDIF "title: employee";
				&fixTokensCase;
				&fixTokensCaseStud;
		 	}elsif($flag == 3)
		 	{
		 		say OUTPUT_LDIF "objectClass: UPLBStudent";
		 		say OUTPUT_LDIF "objectClass: UPLBAlumni";
		 		say OUTPUT_LDIF "title: student";	
				say OUTPUT_LDIF "title: alumni";
				&fixTokensCase;
		 	}
		 	
		 	say OUTPUT_LDIF "uniqueIdentifierUPLB: $lastUID";
		 	say OUTPUT_LDIF "cn: $identifier";
			&uidProducer;
			say OUTPUT_LDIF "givenName: $tokens[2]";
			if ($tokens[6]) {
				say OUTPUT_LDIF "mail: $tokens[6]";
			}
			if ($mobile) {
				say OUTPUT_LDIF "mobile: $mobile";
			}
			&passwdProducer;
			&displayNameProducer;
		 	say OUTPUT_LDIF "sn: $tokens[1]";
			if ($tokens[5] ne ""){
				$tokens[5] =~ s/Iii/III/;
				$tokens[5] =~ s/Ii/II/;	
				say OUTPUT_LDIF "suffix: $tokens[5]";
			}
		 	say OUTPUT_LDIF "uidNumber: $lastUID";
			$tokens[9] =~ s/\s//g;
			say OUTPUT_LDIF "gidNumber: $tokens[9]"; 
			say OUTPUT_LDIF "homeDirectory: /home/$uid";
			say OUTPUT_LDIF "loginShell: /bin/bash";
			say OUTPUT_LDIF "personalTitle: Mr";
			#different tags for different objectClass( entity types)
			##############
			#UPLBStudent#
			##############
			if($flag == 2)
			{
				say OUTPUT_LDIF "studentNumber: $tokens[0]";
				say OUTPUT_LDIF "studentType: $tokens[7]";
				say OUTPUT_LDIF "course: $tokens[8]";
				say OUTPUT_LDIF "college: $college";	
				say OUTPUT_LDIF "activeStudent: TRUE";
				say OUTPUT_LDIF;	
			}
			elsif($flag == 1)
			#############
			#UPLBEmployee#
			#############
			{
				say OUTPUT_LDIF "employeeNumber: $tokens[0]";
				say OUTPUT_LDIF "employeeType: $tokens[7]";
				say OUTPUT_LDIF "ou: $tokens[8]";
				say OUTPUT_LDIF "o: $college";	
				say OUTPUT_LDIF "activeEmployee: TRUE";
		 		say OUTPUT_LDIF;	
		
			}
			############
			#UPLBAlumni#
			############
			elsif($flag == 3)
			{
				say OUTPUT_LDIF "studentNumber: $tokens[0]";
				say OUTPUT_LDIF "studentType: $tokens[7]";
				say OUTPUT_LDIF "course: $tokens[8]";
				say OUTPUT_LDIF "college: $college";	
				say OUTPUT_LDIF "activeStudent: TRUE";				
				say OUTPUT_LDIF "yearGraduated: XXXX";
				say OUTPUT_LDIF "courseGraduated: $tokens[8]";
				say OUTPUT_LDIF;	
			}
}

1;
