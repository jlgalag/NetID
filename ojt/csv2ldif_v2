#!/usr/bin/perl
###################################################################
#  Script: csv2ldif
#  Author: Tirazona, Ludwig Johann B. <ljbtirazona@uplb.edu.ph>
#  Objective: The purpose of this program is to convert CSV files sent by HRDO and OUR to LDIF, for importation into empty LDAP Servers, and do some other formatting. Expected output is expected input for ldapadd.
#  Date: 13 Dec 2013
#  Requires: Net::LDAP (deb package: libnet-ldap-perl)
#	     Digest::SHA (libdigest-sha-perl)
#  Future Works:
#      - Obtain uniqueIdentifierUPLB automatically from LDAP Server
###################################################################

###########################################################################
#   Initial CSV format from HRDO     Corresponding LDAP attributes
#
#   UPLB Employees I.D. #	     employeeNumber 
#   Last Name		             sn
#   First Name		    	     givenName
#   Middle Name		  	     middleName
#   Nick Name			     cn (cn is multi-value, default cn is "givenName middleInitial(from middleName) sn suffix")
#   Name Suffix		             suffix
#   Email add			     mail
#   Classification		     employeeType
#   Office/College                   o
#   Unit			     ou
#
###########################################################################
# Example CSV Input: 
# 011004449,ABANTO,OLIVER,DIAZ,,,odabanto@up.edu.ph,Faculty,ANIMAL AND DAIRY SCIENCES CLUSTER,CA
# 012005927,ABAO,ELIAS,BALDEMOR,,JR,,REPS,CENTER FOR TECHNOLOGY TRANSFER & ENTREPRENEURSHIP,OVCRE
#
# Should produce an LDIF file for ldapmodify:
# dn: uniqueIdentifierUPLB=1,ou=people,dc=uplb,dc=edu,dc=ph
# changetype: add
# objectClass: UPLBEntity
# objectClass: UPLBEmployee
# uniqueIdentifierUPLB: 1
# cn: Abanto, Oliver D.
# uid: odabanto
# userPassword: <generated by pwgen>
# securityQuestion: <generated by pwgen>
# securityAnswer: <generated by pwgen>
# displayName: Abanto, Oliver D.
# sn: Abanto
# personalTitle: Mr.
# uidNumber: 1
# gidNumber: 1006
# homeDirectory: /home/odabanto
# loginShell: /bin/bash
# employeeNumber: 011004449
# employeeType: Faculty
# ou: ANIMAL AND DAIRY SCIENCES CLUSER
# o: CA
# activeEmployee: Y

# dn: uniqueIdentifierUPLB=2,ou=people,dc=uplb,dc=edu,dc=ph
# changetype: add
# objectClass: UPLBEntity
# objectClass: UPLBEmployee
# uniqueIdentifierUPLB: 2
# cn: Abao, Elias Jr. B.
# uid: ebabaojr
# userPassword: <generated by pwgen>
# securityQuestion: <generated by pwgen>
# securityAnswer: <generated by pwgen>
# displayName: Abao, Elias Jr. B.
# sn: Abao
# suffix: Jr.
# personalTitle: Mr.
# uidNumber: 2
# gidNumber: 1005
# homeDirectory: /home/ebabaojr
# loginShell: /bin/bash
# employeeNumber: 012005927
# employeeType: REPS
# ou: CENTER FOR TECHNOLOGY TRANSFER & ENTREPRENEURSHIP
# o: OVCRE
# activeEmployee: Y

require "subroutines.pl";

use Net::LDAP;
use Digest::SHA;
use MIME::Base64;

##############
# MAIN START #
##############

if (!defined $ARGV[0]){ &printUsage; die "No input file!\n"; }
if (!open INPUT_CSV, "<", $ARGV[0]) { die "Cannot open file: $ARGV[0]\n"; }
if (!defined $ARGV[1]){ &printUsage; die "No output file!\n"; }
if (!open OUTPUT_LDIF, ">", $ARGV[1]) { die "Cannot write to file: $ARGV[1]\n"; }
if (!open PASS_PLAIN_CSV, ">", "password_plain") { die "Cannot open file: password_plain\n"; }

#Check expected number of entries to be generated
$number_of_entries = `wc -l $ARGV[0]`;
@tokens = split(/\s/, $number_of_entries);
$number_of_entries = @tokens[0];
$temp = $number_of_entries*4; # x4 since we need three random values for every entry and another set for salt
#pre-generate passwords so we don't have to call pwgen everytime
@passwords_generated = split(/\n/, `pwgen -c -n -1 8 $temp`);

#Obtain uidIdentifierUPLB
$ldap_server_ip_and_port = "10.0.100.201:389";
$ldap = Net::LDAP->new( $ldap_server_ip_and_port ) or die "Could not connect to LDAP Server!";
print "Enter bind DN Password: ";
# Code non-portable (UNIX/Linux only)
	system('stty','-echo');
	chop($password=<STDIN>);
	system('stty','echo');
# End non-portable

$mesg = $ldap->bind( "cn=admin,dc=uplb,dc=edu,dc=ph", password => $password );
if ($mesg->code){ die "Fatal Error: Authentication Fail\n"; }
#Retrieve uidLatestNumber
$mesg = $ldap->search(
                        base   => "ou=numberHolder,dc=uplb,dc=edu,dc=ph",
                        filter => "(cn=uidLatestNumber)",
			attrs  => "serialNumber"
                    	  );
if ($mesg->code){ die "Fatal Error: Could not find latest uidIdentifierUPLB\n"; }
@entry  = $mesg->entries;
$lastUID = $entry[0]->get_value('serialNumber');
print "\nLast UID: ", $lastUID, "\n";

#Retrieve gidGroups
 $mesg = $ldap->search(
                base   => "ou=posixGroups,dc=uplb,dc=edu,dc=ph",
                filter => "(cn=*)",
                attrs  => "gidNumber"
              );
foreach $entry ($mesg->entries){
   my $cn_a = $entry->get_value("cn");
   my $gidNumber_a = $entry->get_value("gidNumber");
	$gidNumbers{$cn_a} = $gidNumber_a;
	#print "cn: $cn_a\n"; #DEBUG
	#print "gidNumber: $gidNumber_a\n"; #DEBUG
}



$entryCounter = 0;
# Process lines
foreach $line (<INPUT_CSV>)  {  
 	@tokens = split(/,/, $line);
	#clean up tokens
	#eliminate trailing and leading spaces
	$temp_counter = 0;
	foreach $temp (@tokens){
		$temp =~ s/(^\s)|(\s$)//g;
		$tokens[$temp_counter] = $temp;	
		$temp_counter++;
	}
	$college = $tokens[9];
	$college =~ s/\s//g;
	$tokens[9] = ($gidNumbers{$college});
=for comment
	 DEBUG Test output tokens
		for ($i = 0; $i <= $#tokens; $i++) {
			print "$tokens[$i] \n";
		}

=cut
#obtain the cn of each entry to act as an identifier for it. this will be used to check for existing entries
 	$identifier = &cnProducer;
#store employee/student number to determine whether an entities objectClass
 	$eNumber = $tokens[0];
#check if entity is a student or an employee
	$check = index($eNumber, "-");
	if($check != -1) {
	#if check is not equal to 1, entity is a student or an alumni
		$flag = 2;
		&fixTokensCase;
		&fixTokensCaseStud;
	}else {
	#if it is equal to 1, entity is an employee
		$flag = 1;
		&fixTokensCase;
	}
#determines if there is already a duplicate entry in the server. the function would return a value that would decide what to do
 	$branch = &findDuplicate;
 #if returned value is 4, there is no duplicate therefore it would be added in the server
 	if($branch eq 4) {
 		$lastUID++;
		&addNewEntry;
		$entryCounter++;
	}elsif($branch eq 1) {
	#record already exists if value is 1 and must proceed to next entry
		next;
	}elsif($branch eq 2) {
	#gets uidNumber of the entity so we can modify it
		$UIDUPLB = &getUIDUPLB;
	#add employee attributes
		&addEmployeeAttributes;
	}elsif($branch eq 3) {
	#gets uidNumber of the entity so we can modify it
		$UIDUPLB = &getUIDUPLB;
	#add student attributes
		&addStudentAttributes;
	}
}

#updates latest uid on ldap server
say OUTPUT_LDIF "dn: cn=uidLatestNumber,ou=numberHolder,dc=uplb,dc=edu,dc=ph";
say OUTPUT_LDIF "changetype: modify";
say OUTPUT_LDIF "replace: serialNumber";
say OUTPUT_LDIF "serialNumber: $lastUID";

#$intoLDAP = `ldapmodify -h 10.0.100.201 -p 389 -D "cn=admin,dc=uplb,dc=edu,dc=ph" -w testtesttest -f staff.ldif`;

#Close all handlers and streams
$ldap->unbind;
close OUTPUT_CSV;
close INPUT_CSV;
close PASS_PLAIN;
